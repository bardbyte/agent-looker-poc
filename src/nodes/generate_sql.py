"""SQL generation node - uses Looker MCP to generate deterministic SQL."""

from ..state import AgentState
from ..adapter import SafeChainAdapter


async def generate_sql_node(
    state: AgentState,
    adapter: SafeChainAdapter,
) -> dict:
    """
    Generate SQL using Looker MCP's query_sql tool.

    This node:
    1. Takes the selected model, explore, dimensions, measures, filters
    2. Calls Looker MCP to generate the SQL
    3. Returns the deterministic SQL (not executed)

    The SQL is generated by Looker's semantic layer, not by the LLM,
    ensuring correctness and consistency.
    """
    field_selection = state.get("field_selection")

    if not field_selection:
        return {"error": "No field selection available"}

    model = field_selection.get("model")
    explore = field_selection.get("explore")
    dimensions = field_selection.get("dimensions", [])
    measures = field_selection.get("measures", [])
    filters = field_selection.get("filters", {})

    explanation_trace = list(state.get("explanation_trace", []))
    explanation_trace.append("ðŸ’¾ Generating SQL via Looker...")
    explanation_trace.append(f"   Model: {model}")
    explanation_trace.append(f"   Explore: {explore}")
    explanation_trace.append(f"   Dimensions: {dimensions}")
    explanation_trace.append(f"   Measures: {measures}")
    if filters:
        explanation_trace.append(f"   Filters: {filters}")

    try:
        # Call Looker MCP to generate SQL
        # The tool name might be 'query_sql' or similar
        result = await adapter.invoke_tool(
            "query_sql",
            model=model,
            explore=explore,
            dimensions=dimensions,
            measures=measures,
            filters=filters,
        )

        # Extract SQL from result
        sql = _extract_sql(result)

        if sql:
            explanation_trace.append("âœ… SQL generated successfully")
            return {
                "generated_sql": sql,
                "explanation_trace": explanation_trace,
            }
        else:
            explanation_trace.append("âŒ No SQL returned from Looker")
            return {
                "error": "Looker did not return SQL",
                "explanation_trace": explanation_trace,
            }

    except Exception as e:
        error_msg = str(e)
        explanation_trace.append(f"âŒ SQL generation error: {error_msg}")

        # Try alternative: maybe the tool is named differently
        if "not found" in error_msg.lower():
            explanation_trace.append("   Trying alternative tool name...")
            try:
                result = await adapter.invoke_tool(
                    "generate_sql",
                    model=model,
                    explore=explore,
                    dimensions=dimensions,
                    measures=measures,
                    filters=filters,
                )
                sql = _extract_sql(result)
                if sql:
                    return {
                        "generated_sql": sql,
                        "explanation_trace": explanation_trace,
                    }
            except Exception:
                pass

        return {
            "error": error_msg,
            "explanation_trace": explanation_trace,
        }


def _extract_sql(result) -> str | None:
    """Extract SQL string from tool result."""
    if result is None:
        return None

    # Direct string
    if isinstance(result, str):
        return result.strip()

    # Dict with sql key
    if isinstance(result, dict):
        sql = result.get("sql") or result.get("query") or result.get("content")
        if sql:
            return str(sql).strip()

    # Object with content attribute
    content = getattr(result, "content", None)
    if content:
        return str(content).strip()

    # Try converting to string
    result_str = str(result)
    if "SELECT" in result_str.upper():
        return result_str.strip()

    return None
