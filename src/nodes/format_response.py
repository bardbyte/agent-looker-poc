"""Response formatting node - prepares final output for user."""

from ..state import AgentState


async def format_response_node(state: AgentState) -> dict:
    """
    Format the final response to present to the user.

    This node combines all the results and explanation trace
    into a well-formatted response.
    """
    # Check if we already have a final response (from clarify or schema nodes)
    if state.get("final_response"):
        return {}  # Already formatted

    intent = state.get("intent")
    explanation_trace = state.get("explanation_trace", [])
    error = state.get("error")

    # Handle errors
    if error:
        response = _format_error(error, explanation_trace)
        return {"final_response": response}

    # Handle SQL generation result
    generated_sql = state.get("generated_sql")
    if generated_sql:
        response = _format_sql_response(state, generated_sql, explanation_trace)
        return {"final_response": response}

    # Fallback
    response = _format_fallback(state, explanation_trace)
    return {"final_response": response}


def _format_sql_response(state: dict, sql: str, trace: list) -> str:
    """Format SQL generation response with full explainability."""
    field_selection = state.get("field_selection", {})
    current_query = state.get("current_query", "")

    lines = [
        "âœ… **SQL GENERATED**",
        "",
        "â•" * 50,
        "ðŸ“‹ **YOUR QUESTION:**",
        f"  \"{current_query}\"",
        "",
        "ðŸŽ¯ **FIELD MAPPING:**",
    ]

    # Show field mapping from explanation trace
    for item in trace:
        if "â†’" in item:
            lines.append(f"  {item.strip()}")

    lines.extend([
        "",
        "ðŸ“Š **QUERY STRUCTURE:**",
        f"  â€¢ Model: {field_selection.get('model', 'N/A')}",
        f"  â€¢ Explore: {field_selection.get('explore', 'N/A')}",
        f"  â€¢ Dimensions: {field_selection.get('dimensions', [])}",
        f"  â€¢ Measures: {field_selection.get('measures', [])}",
    ])

    filters = field_selection.get("filters", {})
    if filters:
        lines.append(f"  â€¢ Filters: {filters}")

    lines.extend([
        "",
        "â•" * 50,
        "ðŸ’¾ **GENERATED SQL:**",
        "",
        "```sql",
        sql,
        "```",
        "",
        "â•" * 50,
        "",
        "ðŸ’¡ This SQL was generated by Looker's semantic layer.",
        "   Copy and run it in your preferred query tool.",
    ])

    return "\n".join(lines)


def _format_error(error: str, trace: list) -> str:
    """Format error response."""
    lines = [
        "âŒ **ERROR**",
        "",
        f"  {error}",
        "",
    ]

    if trace:
        lines.append("ðŸ“œ **What happened:**")
        for item in trace[-5:]:  # Last 5 trace items
            lines.append(f"  {item}")

    lines.extend([
        "",
        "ðŸ’¡ **Try:**",
        "  â€¢ Rephrasing your question",
        "  â€¢ Asking \"What data is available?\"",
        "  â€¢ Being more specific about what you're looking for",
    ])

    return "\n".join(lines)


def _format_fallback(state: dict, trace: list) -> str:
    """Format fallback response when nothing specific to show."""
    intent = state.get("intent", "unknown")
    current_query = state.get("current_query", "")

    lines = [
        "ðŸ¤” **I processed your request but don't have a specific output.**",
        "",
        f"  Intent: {intent}",
        f"  Query: \"{current_query}\"",
        "",
    ]

    if trace:
        lines.append("ðŸ“œ **Processing trace:**")
        for item in trace:
            lines.append(f"  {item}")

    lines.extend([
        "",
        "ðŸ’¡ **Try asking:**",
        "  â€¢ \"What data is available?\" - see schema",
        "  â€¢ \"Show me sales by region\" - generate SQL",
        "  â€¢ \"What is total_revenue?\" - explain a field",
    ])

    return "\n".join(lines)
